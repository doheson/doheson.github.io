[{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/tags/android/","section":"Tags","summary":"","title":"Android","type":"tags"},{"content":"Android 15(API 레벨 35) 이상을 타겟팅하는 앱은 기본적으로 전체 디스플레이 영역을 활용한다.\n이 과정에서 안드로이드의 네비게이션바와 앱의 컨텐츠가 겹치는 현상이 발생하여 이슈가 발생했다.\n기존에는 windowOptOutEdgeToEdgeEnforcement 값을 true로 설정하여 EdgeToEdge 현상을 비활성화 했지만,\nAndroid 16부터는 해당 기능을 지원하지 않아 다른 방법을 찾아보던 중, 패딩을 넣는 방식으로 적용했다.\noverride fun onCreate(savedInstanceState: Bundle?) { RNBootSplash.init(this, R.style.BootTheme) // ⬅️ initialize the splash screen super.onCreate(null) // super.onCreate(null) with react-native-screens // API35 이상부터 자동으로 적용되는 EdgeToEdge(네비게이션 바에 겹치는 현상 발생) 기능 방지 // Edge-to-edge 활성화 (시스템 바 영역까지 콘텐츠 확장) WindowCompat.setDecorFitsSystemWindows(window, false) // rootView 에 패딩 적용 val rootView = findViewById\u0026lt;View\u0026gt;(android.R.id.content) ViewCompat.setOnApplyWindowInsetsListener(rootView) { view, insets -\u0026gt; val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars()) view.updatePadding( top = systemBars.top, // 상태 바 높이만큼 상단 패딩 추가 bottom = systemBars.bottom // 네비게이션 바 높이만큼 하단 패딩 추가 ) insets } } 출처\nhttps://developer.android.com/about/versions/16/behavior-changes-16?hl=ko#edge-to-edge\n","date":"17 June 2025","externalUrl":null,"permalink":"/posts/android_1/","section":"Posts","summary":"","title":"Android15(API level 35) 이상 대비 Edge to Edge 패딩 처리","type":"posts"},{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/","section":"Blog of doheson","summary":"","title":"Blog of doheson","type":"page"},{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"6 January 2024","externalUrl":null,"permalink":"/tags/cs/","section":"Tags","summary":"","title":"CS","type":"tags"},{"content":"웹에서 데이터 주고받을 때 HTTP, HTTPS 두 가지 프로토콜 많이 씀. 겉보기엔 비슷하지만, 보안에서 큰 차이 있음.\n데이터 전송과 보안\n•\tHTTP는 데이터 암호화 없이 평문으로 전송. 누가 중간에서 엿보면 내용 다 보임. 비밀번호, 개인정보 등 민감한 정보 쉽게 털릴 수 있음.\n•\tHTTPS는 SSL이나 TLS로 데이터 암호화. 누가 가로채도 내용 해독 어려움. 보안 훨씬 강력. 인증서와 신뢰성\n•\tHTTP는 인증서 필요 없음. 서버가 진짜인지 아닌지 알 방법 없음. 피싱 사이트 등 위험 있음.\n•\tHTTPS는 인증기관(CA)에서 발급한 인증서 필요. 브라우저가 인증서 확인해서 신뢰할 수 있는 서버인지 검증. 주소창에 자물쇠 표시됨. 기본 포트\n•\tHTTP는 80번 포트 사용.\n•\tHTTPS는 443번 포트 사용. 성능과 구현 난이도\n•\tHTTP는 암호화 과정 없음. 구현 쉽고 빠름. 대신 보안 취약.\n•\tHTTPS는 암호화/복호화 과정 추가됨. 성능 약간 떨어질 수 있지만, 요즘 하드웨어에선 거의 차이 없음. 인증서 관리 등 운영 조금 더 복잡. 기타 차이\n•\t검색엔진(SEO): HTTPS 쓰면 검색엔진에서 더 높은 점수 받음. 구글 등은 보안 강화된 사이트에 가산점 줌.\n•\t신뢰성: HTTPS는 인증서로 서버 신원 확인. 사용자 신뢰도 높아짐. ","date":"6 January 2024","externalUrl":null,"permalink":"/posts/cs_1_1/","section":"Posts","summary":"","title":"HTTP와 HTTPS의 차이점","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]