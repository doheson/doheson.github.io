[{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/categories/android/","section":"Categories","summary":"","title":"Android","type":"categories"},{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/tags/android/","section":"Tags","summary":"","title":"Android","type":"tags"},{"content":"Android 15(API 레벨 35) 이상을 타겟팅하는 앱은 기본적으로 전체 디스플레이 영역을 활용한다.\n이 과정에서 안드로이드의 네비게이션바와 앱의 컨텐츠가 겹치는 현상이 발생하여 이슈가 발생했다.\n기존에는 windowOptOutEdgeToEdgeEnforcement 값을 true로 설정하여 EdgeToEdge 현상을 비활성화 했지만,\nAndroid 16부터는 해당 기능을 지원하지 않아 다른 방법을 찾아보던 중, 패딩을 넣는 방식으로 적용했다.\noverride fun onCreate(savedInstanceState: Bundle?) { RNBootSplash.init(this, R.style.BootTheme) // ⬅️ initialize the splash screen super.onCreate(null) // super.onCreate(null) with react-native-screens // API35 이상부터 자동으로 적용되는 EdgeToEdge(네비게이션 바에 겹치는 현상 발생) 기능 방지 // Edge-to-edge 활성화 (시스템 바 영역까지 콘텐츠 확장) WindowCompat.setDecorFitsSystemWindows(window, false) // rootView 에 패딩 적용 val rootView = findViewById\u0026lt;View\u0026gt;(android.R.id.content) ViewCompat.setOnApplyWindowInsetsListener(rootView) { view, insets -\u0026gt; val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars()) view.updatePadding( top = systemBars.top, // 상태 바 높이만큼 상단 패딩 추가 bottom = systemBars.bottom // 네비게이션 바 높이만큼 하단 패딩 추가 ) insets } } 출처\nhttps://developer.android.com/about/versions/16/behavior-changes-16?hl=ko#edge-to-edge\n","date":"17 June 2025","externalUrl":null,"permalink":"/posts/android_1/","section":"Posts","summary":"","title":"Android15(API level 35) 이상 대비 Edge to Edge 패딩 처리","type":"posts"},{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/","section":"Blog of doheson","summary":"","title":"Blog of doheson","type":"page"},{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/tags/edge-to-edge/","section":"Tags","summary":"","title":"Edge to Edge","type":"tags"},{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2 March 2024","externalUrl":null,"permalink":"/categories/cs/","section":"Categories","summary":"","title":"CS","type":"categories"},{"content":"","date":"2 March 2024","externalUrl":null,"permalink":"/tags/cs/","section":"Tags","summary":"","title":"CS","type":"tags"},{"content":"","date":"2 March 2024","externalUrl":null,"permalink":"/categories/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9Cos/","section":"Categories","summary":"","title":"운영체제(OS)","type":"categories"},{"content":"","date":"2 March 2024","externalUrl":null,"permalink":"/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9Cos/","section":"Tags","summary":"","title":"운영체제(OS)","type":"tags"},{"content":"운영체제에서 프로그램이 실행될 때, 그 작업을 담당하는 단위가 프로세스와 스레드.\n둘 다 독립적으로 실행되는 흐름이지만, 자원 관리 방식과 역할에서 차이가 큼.\n정의와 구조\n•\t프로세스:\n실행 중인 프로그램 하나하나가 프로세스.\n운영체제로부터 독립된 메모리 공간(코드, 데이터, 힙, 스택 등)을 할당받음.\n서로 다른 프로세스끼리는 메모리 접근 불가.\n통신하려면 IPC(Inter-Process Communication) 같은 별도 방법 필요.\n•\t스레드:\n프로세스 안에서 실제로 작업을 수행하는 실행 흐름의 단위.\n같은 프로세스 내 스레드끼리는 코드, 데이터, 힙 영역을 공유하고, 스택만 따로 가짐.\n메모리 공유 덕분에 데이터 교환이 빠름. 자원 관리와 통신\n•\t프로세스는 완전히 분리된 메모리 구조라서, 다른 프로세스와 데이터 주고받으려면 IPC 등 복잡한 방법 필요.\n독립성 높아서 한 프로세스가 오류 나도 다른 프로세스엔 영향 적음.\n•\t스레드는 같은 프로세스 내에서 메모리 공유.\n데이터 전달이 간단하고 빠름.\n대신, 한 스레드에 문제가 생기면 같은 프로세스 내 다른 스레드에도 영향 줄 수 있음. 생성과 종료, 오버헤드\n•\t프로세스는 생성/종료에 시간이 오래 걸림.\n문맥 교환(Context Switching) 시 오버헤드 큼.\n자원 할당, 해제 등 비용이 큼.\n•\t스레드는 생성/종료가 훨씬 빠름.\n문맥 교환도 가볍고, 자원 소모 적음. 활용 예시 •\t멀티프로세스:\n여러 프로그램을 동시에 실행(예: 웹브라우저, 음악플레이어, 메신저 등 동시 실행).\n•\t멀티스레드:\n하나의 프로그램이 여러 작업을 동시에 처리(예: 웹브라우저에서 탭마다 스레드, 게임에서 로딩/사운드/입력 동시 처리). 정리\n프로세스는 운영체제에서 자원 할당받아 독립적으로 실행되는 단위.\n스레드는 프로세스 내에서 실행 흐름을 담당, 메모리 공유로 빠른 통신 가능.\n안정성은 프로세스, 속도와 효율성은 스레드가 강점.\n","date":"2 March 2024","externalUrl":null,"permalink":"/posts/cs_2_1/","section":"Posts","summary":"","title":"프로세스와 스레드의 차이","type":"posts"},{"content":"","date":"24 February 2024","externalUrl":null,"permalink":"/categories/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/","section":"Categories","summary":"","title":"네트워크","type":"categories"},{"content":"","date":"24 February 2024","externalUrl":null,"permalink":"/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/","section":"Tags","summary":"","title":"네트워크","type":"tags"},{"content":" URL 해석\n•\t브라우저가 입력한 URL을 파싱해서 프로토콜(HTTP/HTTPS), 도메인, 포트, 경로 등 분리함. DNS 조회\n•\t도메인 이름을 IP 주소로 변환해야 서버에 접속 가능.\n•\t먼저 브라우저 캐시, OS 캐시, 라우터 캐시 등에서 IP 주소 있는지 확인.\n•\t없으면 DNS 서버에 요청해서 IP 주소 받아옴. 서버와 TCP 연결\n•\tIP 주소 알면, 해당 서버와 TCP 연결 시도.\n•\t3-way handshake로 연결 성립. HTTP(S) 요청 전송\n•\t연결되면 브라우저가 서버에 HTTP 또는 HTTPS 요청 보냄.\n•\t요청에는 메서드(GET 등), 헤더, 쿠키 등 다양한 정보 포함. 서버가 응답\n•\t서버는 요청 처리 후, HTML/CSS/JS/이미지 등 필요한 리소스 응답. 브라우저 렌더링\n•\t브라우저가 받은 HTML 파싱 → DOM 트리 생성\n•\tCSS 파싱 → CSSOM 트리 생성\n•\tJS 파싱 및 실행\n•\tDOM + CSSOM 합쳐서 Render Tree 생성\n•\tLayout(위치 계산) → Paint(화면에 그리기) → Composition(레이어 조합)\n•\t이 과정에서 페이지가 순차적으로 보임(점진적 렌더링). 화면 출력\n•\t최종적으로 모든 리소스 받아서, 사용자가 보는 웹페이지 완성. 한 줄 요약\nURL 입력 → DNS 조회 → TCP 연결 → HTTP 요청/응답 → 브라우저 렌더링 → 화면 출력\n","date":"24 February 2024","externalUrl":null,"permalink":"/posts/cs_1_8/","section":"Posts","summary":"","title":"웹 동작 방식","type":"posts"},{"content":"웹에서 한 출처(origin)에서 실행 중인 애플리케이션이 다른 출처에 있는 자원에 접근하려고 하면, 브라우저가 기본적으로 막음.\n이걸 막는 이유는 보안 때문(만약 제한이 없다면 악성 사이트가 사용자의 정보를 훔치거나 조작할 수 있음)\n출처(origin)란?\n출처는 도메인, 프로토콜, 포트 세 가지를 모두 포함함.\n이 중 하나라도 다르면 다른 출처로 간주함.\n예를 들어,\n•\thttps://example.com:443\n•\thttp://example.com:80\n•\thttps://api.example.com:443\n이렇게 각각 다른 출처를 의미.\nCORS가 필요한 이유\n•\t브라우저는 기본적으로 **동일 출처 정책(SOP, Same Origin Policy)**를 따름.\n•\tSOP는 다른 출처의 리소스 요청을 차단해서 보안 위협을 줄임.\n•\t하지만 요즘 웹은 여러 출처의 API나 리소스를 함께 쓰는 경우가 많아, SOP만으로는 불편함.\n•\t그래서 서버가 명시적으로 허용하면, 브라우저가 다른 출처 리소스도 안전하게 요청할 수 있게 하는 게 CORS.\nCORS 동작 원리\n•\t클라이언트가 요청 보낼 때 HTTP 헤더에 Origin 필드에 자신의 출처를 담아 서버에 보냄.\n•\t서버는 응답 헤더에 Access-Control-Allow-Origin을 넣어서 허용할 출처를 명시함.\n예: Access-Control-Allow-Origin: https://myfrontend.com\n모든 출처 허용하려면 *로 설정 가능하지만 보안상 주의 필요.\n•\t브라우저가 응답받고 요청한 출처와 서버가 허용한 출처를 비교해서 일치하면 요청 성공, 아니면 차단하고 CORS 에러 발생.\\\nCORS 설정 예시 (Spring Boot 기준)\n•\t서버에서 어떤 출처를 허용할지 설정 가능.\n•\t특정 도메인만 허용하거나, 모든 도메인 허용(*) 가능.\n•\tHTTP 메서드, 헤더 제한도 설정 가능.\n정리\n•\tCORS는 브라우저가 다른 출처의 리소스 요청을 안전하게 허용하도록 하는 메커니즘.\n•\t서버가 허용하지 않으면 브라우저가 요청을 차단함.\n•\t출처가 다르면 기본적으로 요청 불가, 서버가 명시적으로 허용해야 가능.\n•\tSimple Request와 Preflight Request로 나뉘어 동작.\n•\t개발할 때 CORS 에러 만나면 서버 쪽 설정을 확인하고 수정해야 함.\n","date":"17 February 2024","externalUrl":null,"permalink":"/posts/cs_1_7/","section":"Posts","summary":"","title":"CORS(Cross-Origin Resource Sharing)","type":"posts"},{"content":"웹 개발에서 서버와 클라이언트가 데이터를 주고받을 때 자주 쓰는 방식이 RESTful API.\nREST 아키텍처 원칙을 따르는 API를 RESTful API라고 부름.\nRESTful API란?\n•\tREST(Representational State Transfer):\n웹에서 자원(데이터)을 이름(URI)으로 구분하고,\nHTTP 메서드(GET, POST, PUT, DELETE 등)로 자원에 작업을 수행하는 아키텍처 스타일.\n•\tRESTful API:\nREST 원칙을 지키면서 만든 API.\n서버와 클라이언트가 HTTP를 통해 데이터를 주고받음.\nRESTful API의 특징\n•\t자원(Resource):\nURI로 자원(예: /users/1, /posts/2) 지정.\n•\tHTTP 메서드로 작업 구분:\nGET(조회), POST(생성), PUT(수정), DELETE(삭제) 등으로 자원에 작업.\n•\t표현(Representation):\n데이터는 주로 JSON, XML 등으로 전달.\n•\t무상태(Stateless):\n서버는 클라이언트의 상태를 저장하지 않음.\n각 요청은 독립적으로 처리.\n•\t일관성:\n같은 방식으로 요청하면 항상 같은 결과.\nAPI 구조가 예측 가능하고 일관됨.\n•\t캐시 가능:\nGET 요청 등은 캐시 사용 가능. 서버 부하 줄이고 성능 향상.\n•\t클라이언트-서버 구조:\n역할 분리. 서버는 데이터 관리, 클라이언트는 UI/UX 담당.\nRESTful API 동작 방식\n•\t클라이언트가 서버에 HTTP 요청 보냄(예: GET /users/1).\n•\t서버가 요청 처리, 필요한 데이터 준비.\n•\t서버가 응답(데이터, 상태코드 등) 반환.\n•\t클라이언트는 응답 받아서 화면에 표시하거나 후처리.\nRESTful API의 장점\n•\t구조가 단순하고 일관적이라 배우기 쉽고, 사용하기 편함.\n•\t확장성, 유지보수성 뛰어남.\n•\t다양한 언어, 플랫폼에서 쉽게 구현 가능.\n•\tHTTP 기반이라 방화벽, 프록시 등 기존 인프라 활용 가능.\n정리\nRESTful API는 HTTP와 URI, 메서드를 활용해 자원을 명확하게 다루고,\n서버-클라이언트가 효율적으로 통신하게 해주는 표준 방식.\n웹 개발에서 가장 많이 쓰는 API 설계 패턴.\n","date":"10 February 2024","externalUrl":null,"permalink":"/posts/cs_1_6/","section":"Posts","summary":"","title":"RESTful API","type":"posts"},{"content":"네트워크에서 데이터가 어떻게 오가는지 단계별로 나눈 국제 표준 모델이 OSI 7계층.\n각 계층마다 역할이 정해져 있고, 아래에서 위로, 위에서 아래로 데이터가 흘러감.\n물리 계층 (Physical Layer)\n•\t전기 신호, 빛 등 실제 신호로 0과 1을 주고받음.\n•\t케이블, 허브, 리피터 등 실제 장비 담당.\n•\t데이터 단위: 비트(Bit). 데이터링크 계층 (Data Link Layer)\n•\t같은 네트워크 내에서 데이터가 잘 오가도록 프레임 단위로 관리.\n•\t오류 검출, 수정, 흐름 제어, MAC 주소 사용.\n•\t장비: 스위치, 브릿지. 네트워크 계층 (Network Layer)\n•\t여러 네트워크를 거쳐 목적지까지 패킷 전달.\n•\t라우팅, IP 주소 관리.\n•\t라우터, IP 프로토콜. 전송 계층 (Transport Layer)\n•\t데이터가 순서대로, 빠짐없이 도착하게 보장.\n•\t포트 번호로 응용프로그램 구분, TCP/UDP 사용.\n•\t데이터 단위: 세그먼트/데이터그램. 세션 계층 (Session Layer)\n•\t통신 세션(채널) 열고 닫기, 동기화, 복구.\n•\t로그인, 파일 전송 등에서 세션 관리. 표현 계층 (Presentation Layer)\n•\t데이터 형식 변환(예: 문자 인코딩, 이미지 압축), 암호화/복호화.\n•\t서로 다른 시스템 간 데이터 호환성 맞춤. 응용 계층 (Application Layer)\n•\t사용자가 직접 만나는 부분.\n•\t웹, 메일, 파일 전송 등 다양한 서비스 제공.\n•\tHTTP, FTP, SMTP 등. 한 줄 요약\n•\t12계층: 물리적 연결, 데이터 전송(비트/프레임)\n•\t34계층: 네트워크 간 이동, 신뢰성/순서 보장(패킷/세그먼트)\n•\t5~7계층: 세션, 데이터 형식, 사용자 서비스\n","date":"3 February 2024","externalUrl":null,"permalink":"/posts/cs_1_5/","section":"Posts","summary":"","title":"OSI 7계층","type":"posts"},{"content":"네트워크에서 데이터 보낼 때 많이 쓰는 두 가지 프로토콜, TCP와 UDP.\n둘 다 전송계층에서 동작하지만 방식과 특징이 완전히 다름.\n•\tTCP: 신뢰성, 순서 보장, 연결 먼저 맺고 데이터 전송.\n데이터가 중간에 유실되면 재전송. 흐름제어, 혼잡제어 있음.\n웹브라우징, 파일전송, 메일 등에서 사용.\n•\tUDP: 빠른 속도, 연결 과정 없음.\n순서, 오류 체크 안 함. 데이터가 유실돼도 신경 안 씀.\n실시간 스트리밍, 게임, 음성통화 등에서 많이 씀.\n한 줄 요약\n•\tTCP: 느리지만 신뢰성, 순서 보장. 연결/종료 과정(3-way/4-way handshake) 필요.\n•\tUDP: 빠르지만 신뢰성 낮음. 연결 과정 없이 바로 데이터 전송.\n","date":"27 January 2024","externalUrl":null,"permalink":"/posts/cs_1_4/","section":"Posts","summary":"","title":"TCP와 UDP","type":"posts"},{"content":"쿠키와 세션, 두 가지 모두 웹에서 사용자 정보를 기억하게 해주는 기술. 근데 어디에 정보 저장하는지, 보안은 어떤지, 언제까지 유지되는지 차이가 있음.\n정보 저장 위치\n•\t쿠키는 사용자의 브라우저(컴퓨터)에 저장됨. 서버는 쿠키로 정보를 보내고, 브라우저가 그걸 들고 있음. 나중에 서버에 요청할 때마다 쿠키를 같이 보냄.\n•\t세션은 서버에 저장됨. 사용자 브라우저에는 세션 ID만 쿠키로 들고 있음. 서버는 이 세션 ID로 누구인지 구분해서 정보 관리함.\n보안\n•\t쿠키는 브라우저에 저장되기 때문에, 누가 엿보거나 변조할 수 있음. 그래서 보안에 취약함.\n•\t세션은 실제 정보는 서버에 있고, 브라우저엔 세션 ID만 있음. 그래서 보안이 더 좋음. (단, 세션 ID가 탈취당하면 위험할 수 있으니 조심).\n라이프사이클(유지 기간)\n•\t쿠키는 만료시간 설정 가능. 브라우저 꺼도 계속 남아 있을 수 있음. 만료시간 길게 잡으면 쿠키 삭제할 때까지 유지됨.\n•\t세션도 만료시간 설정할 수 있지만, 브라우저를 닫으면 보통 세션도 끝남.\n속도\n•\t쿠키는 정보가 브라우저에 있으니 서버에 요청할 때 빠름. 서버가 추가로 처리할 게 없음.\n•\t세션은 정보가 서버에 있어서, 서버가 세션 ID로 정보 찾아야 하니 쿠키보다 느릴 수 있음\n실제 사용 예시\n•\t쿠키: 로그인 정보 저장(체크박스), 팝업 안 보기, 쇼핑몰 장바구니 등 → 서버 부담 적고, 빠른 처리 필요할 때\n•\t세션: 로그인 상태, 결제 정보 등 보안 중요한 곳 → 보안이 더 중요할 때\n","date":"20 January 2024","externalUrl":null,"permalink":"/posts/cs_1_3/","section":"Posts","summary":"","title":"쿠키(Cookie)와 세션(Session)","type":"posts"},{"content":"REST API나 웹 개발에서 자주 쓰는 HTTP 메서드 4가지\n(GET, POST, PUT, DELETE)\nGET\n•\t리소스 조회할 때 사용.\n•\t서버에 데이터 요청. 요청할 때 필요한 정보는 쿼리스트링으로 전달.\n•\t예시: 게시글 목록 보기, 유저 정보 가져오기.\n•\t서버 데이터 바꾸지 않음. 안전하게 여러 번 호출해도 결과 같음.\nPOST\n•\t새로운 리소스 생성하거나, 데이터 처리할 때 사용.\n•\t요청 데이터는 메시지 바디(body)에 담아서 보냄.\n•\t예시: 회원가입, 게시글 작성, 주문 생성.\n•\t서버 상태 바뀜. 같은 요청 여러 번 보내면 그만큼 데이터 중복 생성될 수 있음(멱등성 없음).\nPUT\n•\t리소스 전체를 대체(덮어쓰기)할 때 사용.\n•\t해당 리소스가 없으면 새로 생성.\n•\t요청 데이터는 메시지 바디에 담음. 수정할 리소스의 URI를 명확히 지정해야 함.\n•\t예시: 유저 정보 전체 수정, 게시글 전체 수정.\n•\t같은 요청 여러 번 보내도 결과 같음(멱등성 있음).\nDELETE\n•\t리소스 삭제할 때 사용.\n•\t예시: 게시글 삭제, 회원 탈퇴.\n•\t삭제 요청 여러 번 보내도 결과 같음(이미 삭제된 상태 유지, 멱등성 있음).\n실제 사용 예시\n•\tGET /users → 유저 목록 조회\n•\tPOST /users → 새 유저 등록\n•\tPUT /users/1 → id가 1인 유저 정보 전체 수정(없으면 새로 만듦)\n•\tDELETE /users/1 → id가 1인 유저 삭제\n","date":"13 January 2024","externalUrl":null,"permalink":"/posts/cs_1_2/","section":"Posts","summary":"","title":"HTTP Method","type":"posts"},{"content":"웹에서 데이터 주고받을 때 HTTP, HTTPS 두 가지 프로토콜 많이 씀. 겉보기엔 비슷하지만, 보안에서 큰 차이 있음.\n데이터 전송과 보안\n•\tHTTP는 데이터 암호화 없이 평문으로 전송. 누가 중간에서 엿보면 내용 다 보임. 비밀번호, 개인정보 등 민감한 정보 쉽게 털릴 수 있음.\n•\tHTTPS는 SSL이나 TLS로 데이터 암호화. 누가 가로채도 내용 해독 어려움. 보안 훨씬 강력. 인증서와 신뢰성\n•\tHTTP는 인증서 필요 없음. 서버가 진짜인지 아닌지 알 방법 없음. 피싱 사이트 등 위험 있음.\n•\tHTTPS는 인증기관(CA)에서 발급한 인증서 필요. 브라우저가 인증서 확인해서 신뢰할 수 있는 서버인지 검증. 주소창에 자물쇠 표시됨. 기본 포트\n•\tHTTP는 80번 포트 사용.\n•\tHTTPS는 443번 포트 사용. 성능과 구현 난이도\n•\tHTTP는 암호화 과정 없음. 구현 쉽고 빠름. 대신 보안 취약.\n•\tHTTPS는 암호화/복호화 과정 추가됨. 성능 약간 떨어질 수 있지만, 요즘 하드웨어에선 거의 차이 없음. 인증서 관리 등 운영 조금 더 복잡. 기타 차이\n•\t검색엔진(SEO): HTTPS 쓰면 검색엔진에서 더 높은 점수 받음. 구글 등은 보안 강화된 사이트에 가산점 줌.\n•\t신뢰성: HTTPS는 인증서로 서버 신원 확인. 사용자 신뢰도 높아짐. ","date":"6 January 2024","externalUrl":null,"permalink":"/posts/cs_1_1/","section":"Posts","summary":"","title":"HTTP와 HTTPS의 차이점","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]