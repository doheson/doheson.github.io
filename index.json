[{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/categories/android/","section":"Categories","summary":"","title":"Android","type":"categories"},{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/tags/android/","section":"Tags","summary":"","title":"Android","type":"tags"},{"content":"Android 15(API 레벨 35) 이상을 타겟팅하는 앱은 기본적으로 전체 디스플레이 영역을 활용한다.\n이 과정에서 안드로이드의 네비게이션바와 앱의 컨텐츠가 겹치는 현상이 발생하여 이슈가 발생했다.\n기존에는 windowOptOutEdgeToEdgeEnforcement 값을 true로 설정하여 EdgeToEdge 현상을 비활성화 했지만,\nAndroid 16부터는 해당 기능을 지원하지 않아 다른 방법을 찾아보던 중, 패딩을 넣는 방식으로 적용했다.\noverride fun onCreate(savedInstanceState: Bundle?) { RNBootSplash.init(this, R.style.BootTheme) // ⬅️ initialize the splash screen super.onCreate(null) // super.onCreate(null) with react-native-screens // API35 이상부터 자동으로 적용되는 EdgeToEdge(네비게이션 바에 겹치는 현상 발생) 기능 방지 // Edge-to-edge 활성화 (시스템 바 영역까지 콘텐츠 확장) WindowCompat.setDecorFitsSystemWindows(window, false) // rootView 에 패딩 적용 val rootView = findViewById\u0026lt;View\u0026gt;(android.R.id.content) ViewCompat.setOnApplyWindowInsetsListener(rootView) { view, insets -\u0026gt; val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars()) view.updatePadding( top = systemBars.top, // 상태 바 높이만큼 상단 패딩 추가 bottom = systemBars.bottom // 네비게이션 바 높이만큼 하단 패딩 추가 ) insets } } 출처\nhttps://developer.android.com/about/versions/16/behavior-changes-16?hl=ko#edge-to-edge\n","date":"17 June 2025","externalUrl":null,"permalink":"/posts/android_1/","section":"Posts","summary":"","title":"Android15(API level 35) 이상 대비 Edge to Edge 패딩 처리","type":"posts"},{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/","section":"Blog of doheson","summary":"","title":"Blog of doheson","type":"page"},{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/tags/edge-to-edge/","section":"Tags","summary":"","title":"Edge to Edge","type":"tags"},{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"17 June 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"20 January 2024","externalUrl":null,"permalink":"/categories/cs/","section":"Categories","summary":"","title":"CS","type":"categories"},{"content":"","date":"20 January 2024","externalUrl":null,"permalink":"/tags/cs/","section":"Tags","summary":"","title":"CS","type":"tags"},{"content":"","date":"20 January 2024","externalUrl":null,"permalink":"/categories/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/","section":"Categories","summary":"","title":"네트워크","type":"categories"},{"content":"","date":"20 January 2024","externalUrl":null,"permalink":"/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/","section":"Tags","summary":"","title":"네트워크","type":"tags"},{"content":"쿠키와 세션, 두 가지 모두 웹에서 사용자 정보를 기억하게 해주는 기술. 근데 어디에 정보 저장하는지, 보안은 어떤지, 언제까지 유지되는지 차이가 있음.\n정보 저장 위치\n•\t쿠키는 사용자의 브라우저(컴퓨터)에 저장됨. 서버는 쿠키로 정보를 보내고, 브라우저가 그걸 들고 있음. 나중에 서버에 요청할 때마다 쿠키를 같이 보냄.\n•\t세션은 서버에 저장됨. 사용자 브라우저에는 세션 ID만 쿠키로 들고 있음. 서버는 이 세션 ID로 누구인지 구분해서 정보 관리함.\n보안\n•\t쿠키는 브라우저에 저장되기 때문에, 누가 엿보거나 변조할 수 있음. 그래서 보안에 취약함.\n•\t세션은 실제 정보는 서버에 있고, 브라우저엔 세션 ID만 있음. 그래서 보안이 더 좋음. (단, 세션 ID가 탈취당하면 위험할 수 있으니 조심).\n라이프사이클(유지 기간)\n•\t쿠키는 만료시간 설정 가능. 브라우저 꺼도 계속 남아 있을 수 있음. 만료시간 길게 잡으면 쿠키 삭제할 때까지 유지됨.\n•\t세션도 만료시간 설정할 수 있지만, 브라우저를 닫으면 보통 세션도 끝남.\n속도\n•\t쿠키는 정보가 브라우저에 있으니 서버에 요청할 때 빠름. 서버가 추가로 처리할 게 없음.\n•\t세션은 정보가 서버에 있어서, 서버가 세션 ID로 정보 찾아야 하니 쿠키보다 느릴 수 있음\n실제 사용 예시\n•\t쿠키: 로그인 정보 저장(체크박스), 팝업 안 보기, 쇼핑몰 장바구니 등 → 서버 부담 적고, 빠른 처리 필요할 때\n•\t세션: 로그인 상태, 결제 정보 등 보안 중요한 곳 → 보안이 더 중요할 때\n","date":"20 January 2024","externalUrl":null,"permalink":"/posts/cs_1_3/","section":"Posts","summary":"","title":"쿠키(Cookie)와 세션(Session)","type":"posts"},{"content":"REST API나 웹 개발에서 자주 쓰는 HTTP 메서드 4가지\n(GET, POST, PUT, DELETE)\nGET\n•\t리소스 조회할 때 사용.\n•\t서버에 데이터 요청. 요청할 때 필요한 정보는 쿼리스트링으로 전달.\n•\t예시: 게시글 목록 보기, 유저 정보 가져오기.\n•\t서버 데이터 바꾸지 않음. 안전하게 여러 번 호출해도 결과 같음.\nPOST\n•\t새로운 리소스 생성하거나, 데이터 처리할 때 사용.\n•\t요청 데이터는 메시지 바디(body)에 담아서 보냄.\n•\t예시: 회원가입, 게시글 작성, 주문 생성.\n•\t서버 상태 바뀜. 같은 요청 여러 번 보내면 그만큼 데이터 중복 생성될 수 있음(멱등성 없음).\nPUT\n•\t리소스 전체를 대체(덮어쓰기)할 때 사용.\n•\t해당 리소스가 없으면 새로 생성.\n•\t요청 데이터는 메시지 바디에 담음. 수정할 리소스의 URI를 명확히 지정해야 함.\n•\t예시: 유저 정보 전체 수정, 게시글 전체 수정.\n•\t같은 요청 여러 번 보내도 결과 같음(멱등성 있음).\nDELETE\n•\t리소스 삭제할 때 사용.\n•\t예시: 게시글 삭제, 회원 탈퇴.\n•\t삭제 요청 여러 번 보내도 결과 같음(이미 삭제된 상태 유지, 멱등성 있음).\n실제 사용 예시\n•\tGET /users → 유저 목록 조회\n•\tPOST /users → 새 유저 등록\n•\tPUT /users/1 → id가 1인 유저 정보 전체 수정(없으면 새로 만듦)\n•\tDELETE /users/1 → id가 1인 유저 삭제\n","date":"13 January 2024","externalUrl":null,"permalink":"/posts/cs_1_2/","section":"Posts","summary":"","title":"HTTP Method","type":"posts"},{"content":"웹에서 데이터 주고받을 때 HTTP, HTTPS 두 가지 프로토콜 많이 씀. 겉보기엔 비슷하지만, 보안에서 큰 차이 있음.\n데이터 전송과 보안\n•\tHTTP는 데이터 암호화 없이 평문으로 전송. 누가 중간에서 엿보면 내용 다 보임. 비밀번호, 개인정보 등 민감한 정보 쉽게 털릴 수 있음.\n•\tHTTPS는 SSL이나 TLS로 데이터 암호화. 누가 가로채도 내용 해독 어려움. 보안 훨씬 강력. 인증서와 신뢰성\n•\tHTTP는 인증서 필요 없음. 서버가 진짜인지 아닌지 알 방법 없음. 피싱 사이트 등 위험 있음.\n•\tHTTPS는 인증기관(CA)에서 발급한 인증서 필요. 브라우저가 인증서 확인해서 신뢰할 수 있는 서버인지 검증. 주소창에 자물쇠 표시됨. 기본 포트\n•\tHTTP는 80번 포트 사용.\n•\tHTTPS는 443번 포트 사용. 성능과 구현 난이도\n•\tHTTP는 암호화 과정 없음. 구현 쉽고 빠름. 대신 보안 취약.\n•\tHTTPS는 암호화/복호화 과정 추가됨. 성능 약간 떨어질 수 있지만, 요즘 하드웨어에선 거의 차이 없음. 인증서 관리 등 운영 조금 더 복잡. 기타 차이\n•\t검색엔진(SEO): HTTPS 쓰면 검색엔진에서 더 높은 점수 받음. 구글 등은 보안 강화된 사이트에 가산점 줌.\n•\t신뢰성: HTTPS는 인증서로 서버 신원 확인. 사용자 신뢰도 높아짐. ","date":"6 January 2024","externalUrl":null,"permalink":"/posts/cs_1_1/","section":"Posts","summary":"","title":"HTTP와 HTTPS의 차이점","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]